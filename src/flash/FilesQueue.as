package {	import flash.events.ProgressEvent;	import flash.net.FileReference;		public class FilesQueue {		private var parent:Uploader;				private var files:Array;		private var current:File;				private var bytesCurrent:uint;		private var bytesLoaded:uint;		private var bytesTotal:uint;				public function FilesQueue(upload:Uploader):void {			parent = upload;			reset();		}				private function reset():void {			files 			= [];			current 		= null;			bytesCurrent	= 0;			bytesLoaded		= 0;			bytesTotal		= 0;		}		public function push(file:File):void {			bytesTotal += file.size;						files.push(file);		}				public function select(files:Array):void {			var exported:Array = [];			var queue:FilesQueue = this;			files.forEach(function(reference:FileReference, index:uint, self:Array):void {				var file:File = new File(queue, reference);				if (file.isValid){					queue.push(file);					exported.push(file.export());				}			});						notify('select', {files: exported});		}				//		// Methods used by Uploader ( external API )		//				public function start():void {			if (!files.length) return notify('empty');			if (!current) next();		}						public function remove(id:Number):void {			if (current && current.id == id){				current.stop();				uploadEnd();			} else {							files.some(function(file:File, index:uint, array:Array):Boolean {					if (file.id != id) return false;										file.destroy();					array.splice(index, 1);					return true;				});			}						notify('removed');		}				private function next():void {			if (files.length == 0) return;						current = files.shift();			bytesCurrent = 0;						if (!current.start()){				current = null;				return next();			}						notify('start');		}				public function stop():void {			if (current){				current.stop();				files.unshift(current);				bytesLoaded -= bytesCurrent;								notify('stop');								current = null;			}		}				public function clear():void {			if (current) current.stop();						reset();		}				//		// Methods used by File		//				public function get options():Object {			return parent.options;		}				public function hasFile(check:File):Boolean {			return files.some(function(current:File, i:uint, self:Array){				return (current.reference == check.reference) || (					check.reference.name == current.reference.name && 					check.reference.size == current.reference.size && 					check.reference.creationDate.valueOf() == current.reference.creationDate.valueOf()				);			});		}				public function progress(e:ProgressEvent):void {			bytesLoaded += e.bytesLoaded-bytesCurrent;			bytesCurrent =  e.bytesLoaded;						notify('progress', {				   percent: 		(e.bytesLoaded / e.bytesTotal) * 100,				   percentTotal: 	(  bytesLoaded /   bytesTotal) * 100			});		}				public function uploaded(text:String): void{			uploadEnd('completed', {responseText: text});		}				public function error(error:String, message:String):void {			uploadEnd('error', {error:error, message: message});		}				private function uploadEnd(event:String = null, data:Object = null):void {			if (!current) return;						if (event) notify(event, data);						current.destroy();			current = null;				next();		}				//		// Notify & Export		//				private function notify(name:String, data:Object = null):void {			if (!data){				data = {};			}						if (current){				data.id	  = current.id;				data.file = current.export();			}						data.queue 	= {				bytesLoaded:	bytesLoaded,				bytesTotal:		bytesTotal,				count:			files.length,				uploading:		current ? current.id : 0			};			parent.notify(name, data);		}	}}